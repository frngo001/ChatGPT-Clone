import{Q as M}from"./index--NVultsq.js";function D(t,m){let e;try{e=t()}catch{return}return{getItem:a=>{var r;const i=l=>l===null?null:JSON.parse(l,void 0),d=(r=e.getItem(a))!=null?r:null;return d instanceof Promise?d.then(i):i(d)},setItem:(a,r)=>e.setItem(a,JSON.stringify(r,void 0)),removeItem:a=>e.removeItem(a)}}const S=t=>m=>{try{const e=t(m);return e instanceof Promise?e:{then(s){return S(s)(e)},catch(s){return this}}}catch(e){return{then(s){return this},catch(s){return S(s)(e)}}}},C=(t,m)=>(e,s,a)=>{let r={storage:D(()=>localStorage),partialize:n=>n,version:0,merge:(n,g)=>({...g,...n}),...m},i=!1;const d=new Set,l=new Set;let c=r.storage;if(!c)return t((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),e(...n)},s,a);const v=()=>{const n=r.partialize({...s()});return c.setItem(r.name,{state:n,version:r.version})},I=a.setState;a.setState=(n,g)=>(I(n,g),v());const f=t((...n)=>(e(...n),v()),s,a);a.getInitialState=()=>f;let h;const P=()=>{var n,g;if(!c)return;i=!1,d.forEach(o=>{var u;return o((u=s())!=null?u:f)});const p=((g=r.onRehydrateStorage)==null?void 0:g.call(r,(n=s())!=null?n:f))||void 0;return S(c.getItem.bind(c))(r.name).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==r.version){if(r.migrate){const u=r.migrate(o.state,o.version);return u instanceof Promise?u.then(y=>[!0,y]):[!0,u]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,o.state];return[!1,void 0]}).then(o=>{var u;const[y,w]=o;if(h=r.merge(w,(u=s())!=null?u:f),e(h,!0),y)return v()}).then(()=>{p?.(h,void 0),h=s(),i=!0,l.forEach(o=>o(h))}).catch(o=>{p?.(void 0,o)})};return a.persist={setOptions:n=>{r={...r,...n},n.storage&&(c=n.storage)},clearStorage:()=>{c?.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>P(),hasHydrated:()=>i,onHydrate:n=>(d.add(n),()=>{d.delete(n)}),onFinishHydration:n=>(l.add(n),()=>{l.delete(n)})},r.skipHydration||P(),h||f},b=C,_=M()(b((t,m)=>({base64Images:null,chats:{},currentChatId:null,selectedModel:null,selectedProvider:"ollama",userName:"Anonymous",isDownloading:!1,downloadProgress:0,downloadingModel:null,temperature:.7,topP:.9,maxTokens:1e6,batchSize:20,throttleDelay:50,systemPrompt:"You are a helpful AI assistant. Please provide accurate and helpful responses.",setBase64Images:e=>t({base64Images:e}),setUserName:e=>t({userName:e}),setCurrentChatId:e=>t({currentChatId:e}),setSelectedModel:e=>t({selectedModel:e}),setSelectedProvider:e=>t({selectedProvider:e}),getChatById:e=>m().chats[e],getMessagesById:e=>m().chats[e]?.messages||[],saveMessages:(e,s)=>{t(a=>{const r=a.chats[e];return{chats:{...a.chats,[e]:{messages:[...s],createdAt:r?.createdAt||new Date().toISOString()}}}})},handleDelete:(e,s)=>{t(a=>{const r=a.chats[e];if(!r)return a;if(s){const l=r.messages.filter(c=>c.id!==s);return{chats:{...a.chats,[e]:{...r,messages:l}}}}const{[e]:i,...d}=a.chats;return{chats:d}})},updateMessage:(e,s,a)=>{t(r=>{const i=r.chats[e];if(!i)return r;const d=i.messages.map(l=>l.id===s?{...l,content:a}:l);return{chats:{...r.chats,[e]:{...i,messages:d}}}})},startDownload:e=>t({isDownloading:!0,downloadingModel:e,downloadProgress:0}),stopDownload:()=>t({isDownloading:!1,downloadingModel:null,downloadProgress:0}),setDownloadProgress:e=>t({downloadProgress:e}),setTemperature:e=>t({temperature:e}),setTopP:e=>t({topP:e}),setMaxTokens:e=>t({maxTokens:e}),setBatchSize:e=>t({batchSize:e}),setThrottleDelay:e=>t({throttleDelay:e}),setSystemPrompt:e=>t({systemPrompt:e})}),{name:"nextjs-ollama-ui-state",partialize:t=>({chats:t.chats,currentChatId:t.currentChatId,selectedModel:t.selectedModel,selectedProvider:t.selectedProvider,userName:t.userName,temperature:t.temperature,topP:t.topP,maxTokens:t.maxTokens,batchSize:t.batchSize,throttleDelay:t.throttleDelay,systemPrompt:t.systemPrompt})}));export{_ as u};
