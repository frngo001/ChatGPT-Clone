import{Q as C}from"./index-DIMaQiqK.js";function D(a,m){let e;try{e=a()}catch{return}return{getItem:s=>{var t;const i=l=>l===null?null:JSON.parse(l,void 0),d=(t=e.getItem(s))!=null?t:null;return d instanceof Promise?d.then(i):i(d)},setItem:(s,t)=>e.setItem(s,JSON.stringify(t,void 0)),removeItem:s=>e.removeItem(s)}}const S=a=>m=>{try{const e=a(m);return e instanceof Promise?e:{then(n){return S(n)(e)},catch(n){return this}}}catch(e){return{then(n){return this},catch(n){return S(n)(e)}}}},P=(a,m)=>(e,n,s)=>{let t={storage:D(()=>localStorage),partialize:r=>r,version:0,merge:(r,g)=>({...g,...r}),...m},i=!1;const d=new Set,l=new Set;let u=t.storage;if(!u)return a((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),e(...r)},n,s);const p=()=>{const r=t.partialize({...n()});return u.setItem(t.name,{state:r,version:t.version})},I=s.setState;s.setState=(r,g)=>(I(r,g),p());const f=a((...r)=>(e(...r),p()),n,s);s.getInitialState=()=>f;let h;const w=()=>{var r,g;if(!u)return;i=!1,d.forEach(o=>{var c;return o((c=n())!=null?c:f)});const v=((g=t.onRehydrateStorage)==null?void 0:g.call(t,(r=n())!=null?r:f))||void 0;return S(u.getItem.bind(u))(t.name).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==t.version){if(t.migrate){const c=t.migrate(o.state,o.version);return c instanceof Promise?c.then(y=>[!0,y]):[!0,c]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,o.state];return[!1,void 0]}).then(o=>{var c;const[y,M]=o;if(h=t.merge(M,(c=n())!=null?c:f),e(h,!0),y)return p()}).then(()=>{v?.(h,void 0),h=n(),i=!0,l.forEach(o=>o(h))}).catch(o=>{v?.(void 0,o)})};return s.persist={setOptions:r=>{t={...t,...r},r.storage&&(u=r.storage)},clearStorage:()=>{u?.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>w(),hasHydrated:()=>i,onHydrate:r=>(d.add(r),()=>{d.delete(r)}),onFinishHydration:r=>(l.add(r),()=>{l.delete(r)})},t.skipHydration||w(),h||f},_=P,N=C()(_((a,m)=>({base64Images:null,chats:{},currentChatId:null,selectedModel:null,userName:"Anonymous",isDownloading:!1,downloadProgress:0,downloadingModel:null,setBase64Images:e=>a({base64Images:e}),setUserName:e=>a({userName:e}),setCurrentChatId:e=>a({currentChatId:e}),setSelectedModel:e=>a({selectedModel:e}),getChatById:e=>m().chats[e],getMessagesById:e=>m().chats[e]?.messages||[],saveMessages:(e,n)=>{a(s=>{const t=s.chats[e];return{chats:{...s.chats,[e]:{messages:[...n],createdAt:t?.createdAt||new Date().toISOString()}}}})},handleDelete:(e,n)=>{a(s=>{const t=s.chats[e];if(!t)return s;if(n){const l=t.messages.filter(u=>u.id!==n);return{chats:{...s.chats,[e]:{...t,messages:l}}}}const{[e]:i,...d}=s.chats;return{chats:d}})},updateMessage:(e,n,s)=>{a(t=>{const i=t.chats[e];if(!i)return t;const d=i.messages.map(l=>l.id===n?{...l,content:s}:l);return{chats:{...t.chats,[e]:{...i,messages:d}}}})},startDownload:e=>a({isDownloading:!0,downloadingModel:e,downloadProgress:0}),stopDownload:()=>a({isDownloading:!1,downloadingModel:null,downloadProgress:0}),setDownloadProgress:e=>a({downloadProgress:e})}),{name:"nextjs-ollama-ui-state",partialize:a=>({chats:a.chats,currentChatId:a.currentChatId,selectedModel:a.selectedModel,userName:a.userName})}));export{N as u};
