import{r as c,j as b,H as p}from"./index-B_HhO1BD.js";function $(e,o,{checkForDefaultPrevented:t=!0}={}){return function(r){if(e?.(r),t===!1||!r.defaultPrevented)return o?.(r)}}function j(e,o){const t=c.createContext(o),i=u=>{const{children:s,...n}=u,f=c.useMemo(()=>n,Object.values(n));return b.jsx(t.Provider,{value:f,children:s})};i.displayName=e+"Provider";function r(u){const s=c.useContext(t);if(s)return s;if(o!==void 0)return o;throw new Error(`\`${u}\` must be used within \`${e}\``)}return[i,r]}function _(e,o=[]){let t=[];function i(u,s){const n=c.createContext(s),f=t.length;t=[...t,s];const d=a=>{const{scope:x,children:h,...v}=a,C=x?.[e]?.[f]||n,m=c.useMemo(()=>v,Object.values(v));return b.jsx(C.Provider,{value:m,children:h})};d.displayName=u+"Provider";function l(a,x){const h=x?.[e]?.[f]||n,v=c.useContext(h);if(v)return v;if(s!==void 0)return s;throw new Error(`\`${a}\` must be used within \`${u}\``)}return[d,l]}const r=()=>{const u=t.map(s=>c.createContext(s));return function(n){const f=n?.[e]||u;return c.useMemo(()=>({[`__scope${e}`]:{...n,[e]:f}}),[n,f])}};return r.scopeName=e,[i,g(r,...o)]}function g(...e){const o=e[0];if(e.length===1)return o;const t=()=>{const i=e.map(r=>({useScope:r(),scopeName:r.scopeName}));return function(u){const s=i.reduce((n,{useScope:f,scopeName:d})=>{const a=f(u)[`__scope${d}`];return{...n,...a}},{});return c.useMemo(()=>({[`__scope${o.scopeName}`]:s}),[s])}};return t.scopeName=o.scopeName,t}var S=globalThis?.document?c.useLayoutEffect:()=>{},E=p[" useId ".trim().toString()]||(()=>{}),R=0;function H(e){const[o,t]=c.useState(E());return S(()=>{t(i=>i??String(R++))},[e]),e||(o?`radix-${o}`:"")}var w=p[" useInsertionEffect ".trim().toString()]||S;function I({prop:e,defaultProp:o,onChange:t=()=>{},caller:i}){const[r,u,s]=y({defaultProp:o,onChange:t}),n=e!==void 0,f=n?e:r;{const l=c.useRef(e!==void 0);c.useEffect(()=>{const a=l.current;a!==n&&console.warn(`${i} is changing from ${a?"controlled":"uncontrolled"} to ${n?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),l.current=n},[n,i])}const d=c.useCallback(l=>{if(n){const a=z(l)?l(e):l;a!==e&&s.current?.(a)}else u(l)},[n,e,u,s]);return[f,d]}function y({defaultProp:e,onChange:o}){const[t,i]=c.useState(e),r=c.useRef(t),u=c.useRef(o);return w(()=>{u.current=o},[o]),c.useEffect(()=>{r.current!==t&&(u.current?.(t),r.current=t)},[t,r]),[t,i,u]}function z(e){return typeof e=="function"}function M(e){const o=c.useRef(e);return c.useEffect(()=>{o.current=e}),c.useMemo(()=>(...t)=>o.current?.(...t),[])}function k(e){const[o,t]=c.useState(void 0);return S(()=>{if(e){t({width:e.offsetWidth,height:e.offsetHeight});const i=new ResizeObserver(r=>{if(!Array.isArray(r)||!r.length)return;const u=r[0];let s,n;if("borderBoxSize"in u){const f=u.borderBoxSize,d=Array.isArray(f)?f[0]:f;s=d.inlineSize,n=d.blockSize}else s=e.offsetWidth,n=e.offsetHeight;t({width:s,height:n})});return i.observe(e,{box:"border-box"}),()=>i.unobserve(e)}else t(void 0)},[e]),o}export{$ as a,k as b,_ as c,M as d,H as e,S as f,j as g,I as u};
